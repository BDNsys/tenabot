import os
from django.conf import settings
from typing import Dict, Any, List

def format_latex_list(items: List[str]) -> str:
    """Formats a Python list of strings into a LaTeX itemize environment."""
    if not items:
        return ""
    
    # Simple list (e.g., for Skills, Core Values)
    latex_list = "\n".join([f"\\item {item}" for item in items])
    return f"\\begin{{itemize}}[label=-]\n{latex_list}\n\\end{{itemize}}"

def format_work_history(work_history: List[Dict[str, str]]) -> str:
    """Formats the work history list into moderncv's cventry format."""
    entries = []
    # cventry requires 6 arguments: years, title, company, city, grade, description
    # We map to: {years}, {title}, {company}, {}, {}, {description}
    for entry in work_history:
        years = f"{entry.get('start_date', '')}--{entry.get('end_date', '')}"
        title = entry.get('title', 'N/A')
        company = entry.get('company', 'N/A')
        summary = entry.get('summary', 'No summary provided.')

        # Use an itemize list for the summary for better formatting
        description_list = f"\\begin{{itemize}}[label={{$\bullet$}}, itemsep=0pt]\n\\item {summary}\n\\end{{itemize}}"
        
        # NOTE: \cventry must have exactly 6 arguments. Empty braces {} are used for unused fields (city, grade)
        entry_latex = f"\\cventry{{{years}}}{{{title}}}{{{company}}}{{}}{{{description_list}}}"
        entries.append(entry_latex)
        
    return "\n\n".join(entries)


def generate_harvard_pdf(resume_data: Dict[str, Any], telegram_id: int) -> str:
    """
    Generates the content for a LaTeX document using the moderncv class.
    
    Returns: The absolute path to the generated .tex file.
    """
    
    # 1. Define output path (we save the .tex file next to the media root)
    # The actual PDF compilation happens externally, but we prepare the source file.
    output_dir = os.path.join(settings.MEDIA_ROOT, 'generated_resumes')
    os.makedirs(output_dir, exist_ok=True)
    
    # Use the telegram_id and current timestamp for a unique file name
    filename_base = f"resume_{telegram_id}_{int(os.time())}"
    tex_path = os.path.join(output_dir, f"{filename_base}.tex")
    pdf_path = os.path.join(output_dir, f"{filename_base}.pdf")
    
    
    # --- Data Extraction ---
    # We extract data from the structure stored in the ResumeInfo model's structured_json
    contact_name = f"User {telegram_id}" # Placeholder, as name isn't stored in ResumeInfo
    phone = resume_data.get('phone', 'N/A')
    email = resume_data.get('email', 'N/A')
    linkedin = resume_data.get('linkedin', 'N/A')
    
    # Extract lists
    work_history = resume_data.get('work_history', [])
    skills = resume_data.get('skills', [])
    core_values = resume_data.get('core_values', [])
    full_education = resume_data.get('full_education', [])
    
    # Format sections
    work_history_latex = format_work_history(work_history)
    skills_latex = format_latex_list(skills)
    core_values_latex = format_latex_list(core_values)
    
    # Simple education summary for the header
    education_level = resume_data.get('education_level', 'Education Summary')
    
    
    # --- LaTeX Content (Using moderncv for structure) ---
    
    # NOTE: In a real-world scenario, you would run 'pdflatex' or similar here.
    # For this environment, we just create the .tex file and assume successful compilation
    # to the corresponding .pdf file path.
    
    latex_content = f"""
\\documentclass[11pt, a4paper]{{moderncv}}
\\moderncvstyle{{casual}} % Harvard-style is often simple/casual
\\moderncvcolor{{blue}}  % Optional color
\\usepackage[utf8]{{inputenc}}
\\usepackage[T1]{{fontenc}}
\\usepackage{{ragged2e}}
\\usepackage[scale=0.8]{{geometry}}

% Personal data
\\name{{{contact_name}}}{{}}
\\title{{{resume_data.get('position_inferred', 'Professional Resume')}}}
\\address{{}}{{}}{{}} % Address optional
\\mobile{{{phone}}}
\\email{{{email}}}
\\social[linkedin]{{https://linkedin.com/in/profile}}{{{linkedin}}}
% Ensure command exists even if data is missing, using a placeholder for the URL
\\extrainfo{{}} 

\\begin{{document}}
\\makecvtitle

% --- Core Values / Summary ---
\\section{{Professional Summary}}
\\begin{{itemize}}[label={{$\\star$}}]
\\item This resume was generated by Tenabot using Gemini AI to extract and structure data.
\\end{{itemize}}

\\section{{Core Values}}
{core_values_latex}


% --- Experience ---
\\section{{Experience}}
{work_history_latex}


% --- Education ---
\\section{{Education}}
\\cvitem{{{education_level}}}{{
    % List all education entries (simple list for brevity)
    \\begin{{itemize}}[itemsep=0pt]
"""

    for edu in full_education:
        latex_content += f"        \\item \\textbf{{{edu.get('degree')}}} in {edu.get('field_of_study')} from {edu.get('institution')} ({edu.get('graduation_date')})\n"

    latex_content += f"""
    \\end{{itemize}}
}}


% --- Skills ---
\\section{{Skills}}
{skills_latex}


\\end{{document}}
"""

    # 2. Write the LaTeX content to the .tex file
    try:
        with open(tex_path, 'w', encoding='utf-8') as f:
            f.write(latex_content)
        
        # 3. Simulate compilation by creating an empty PDF file
        # In a real setup, a command like subprocess.run(["pdflatex", tex_path]) would run here.
        # We assume success and create the target PDF file path.
        with open(pdf_path, 'w') as f:
            f.write("") # Write empty content to create the file
            
        return pdf_path # Return the path to the expected PDF
    
    except Exception as e:
        print(f"Error generating or saving LaTeX/PDF files: {e}")
        return None
